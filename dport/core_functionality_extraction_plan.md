# ElectricEye Porting and Extraction Plan

This document outlines the technical plan for extracting the core features of the ElectricEye tool and porting them into a new, modern Python Django application named `joemccray/ElectricEye`.

## 1. Guiding Principles

*   **Native Integration:** The new Django app will natively integrate the features of ElectricEye, not just wrap the existing scripts. This means re-implementing the logic in a Django-native way to ensure scalability, maintainability, and better integration with the Django ecosystem.
*   **Modular Architecture:** The application will be designed with a modular architecture to ensure future scalability and maintainability. Each major component of the application will be a separate Django app.
*   **Asynchronous by Design:** The security audits can be long-running processes. Therefore, the application will be designed to run them asynchronously using Celery and Redis.
*   **API First:** The application will be built with an API-first approach, using Django REST Framework to expose all functionalities through a REST API.

## 2. Modular Architecture

The Django project will be structured into the following apps:

*   `core`: This app will contain the core models, business logic, and utilities that are shared across the application.
*   `auditors`: This app will be responsible for managing the auditors and checks. It will contain the logic for running the audits.
*   `findings`: This app will be responsible for storing and managing the findings generated by the auditors.
*   `assets`: This app will be responsible for managing the discovered cloud assets.
*   `compliance`: This app will be responsible for managing the compliance frameworks and controls.
*   `api`: This app will contain the REST API endpoints for the application.
*   `ui`: This app will contain the user interface for the application (optional, can be a separate frontend application).

## 3. Database Schema

The following database models will be created to store the data for the application.

### `core` app:

*   `Platform`:
    *   `name`: `CharField` (e.g., "AWS", "GCP")
    *   `slug`: `SlugField` (e.g., "aws", "gcp")

*   `Service`:
    *   `name`: `CharField` (e.g., "Amazon S3", "Google Compute Engine")
    *   `slug`: `SlugField` (e.g., "s3", "gce")
    *   `platform`: `ForeignKey` to `Platform`

### `auditors` app:

*   `Auditor`:
    *   `name`: `CharField` (e.g., "AWS S3 Auditor")
    *   `slug`: `SlugField` (e.g., "aws-s3-auditor")
    *   `service`: `ForeignKey` to `Service`
    *   `description`: `TextField`

*   `Check`:
    *   `name`: `CharField` (e.g., "S3 Bucket Publicly Accessible")
    *   `slug`: `SlugField` (e.g., "s3-bucket-publicly-accessible")
    *   `auditor`: `ForeignKey` to `Auditor`
    *   `description`: `TextField`
    *   `remediation`: `TextField`

### `findings` app:

*   `Finding`:
    *   `resource_id`: `CharField`
    *   `status`: `CharField` (e.g., "Pass", "Fail", "Info")
    *   `description`: `TextField`
    *   `check`: `ForeignKey` to `Check`
    *   `asset`: `ForeignKey` to `Asset`
    *   `timestamp`: `DateTimeField`

### `assets` app:

*   `Asset`:
    *   `asset_id`: `CharField`
    *   `asset_type`: `CharField` (e.g., "aws_s3_bucket", "gcp_compute_instance")
    *   `platform`: `ForeignKey` to `Platform`
    *   `region`: `CharField`
    *   `details`: `JSONField`

### `compliance` app:

*   `ComplianceFramework`:
    *   `name`: `CharField` (e.g., "NIST CSF")
    *   `version`: `CharField` (e.g., "1.1")

*   `Control`:
    *   `name`: `CharField` (e.g., "PR.AC-1")
    *   `description`: `TextField`
    *   `framework`: `ForeignKey` to `ComplianceFramework`

*   `CheckControlMapping`:
    *   `check`: `ForeignKey` to `Check`
    *   `control`: `ForeignKey` to `Control`

## 4. API Endpoints

The following REST API endpoints will be created using Django REST Framework.

*   `POST /api/audits/`: Start a new audit.
    *   Request body: `{ "platform": "aws", "services": ["s3", "ec2"], "checks": ["s3-bucket-publicly-accessible"] }`
*   `GET /api/audits/{audit_id}/`: Get the status of an audit.
*   `GET /api/findings/`: List all findings.
    *   Filtering: `?platform=aws&service=s3&status=Fail`
*   `GET /api/findings/{finding_id}/`: Get a specific finding.
*   `GET /api/assets/`: List all assets.
*   `GET /api/assets/{asset_id}/`: Get a specific asset.
*   `GET /api/platforms/`: List all supported platforms.
*   `GET /api/services/`: List all supported services.
*   `GET /api/auditors/`: List all auditors.
*   `GET /api/checks/`: List all checks.
*   `GET /api/compliance/frameworks/`: List all compliance frameworks.
*   `GET /api/compliance/controls/`: List all controls.

## 5. Third-Party Libraries

The following third-party libraries will be used in the project:

*   `django`: The web framework.
*   `djangorestframework`: For building the REST API.
*   `psycopg2-binary`: For PostgreSQL database.
*   `celery`: For running asynchronous tasks.
*   `redis`: As a message broker for Celery.
*   `boto3`: For AWS integration.
*   `google-api-python-client`: For GCP integration.
*   `oci`: For OCI integration.
*   `azure-identity`, `azure-mgmt-resource`: For Azure integration.
*   `servicenow-api`: For ServiceNow integration.
*   `msal`: For M365 integration.
*   `simple-salesforce`: For Salesforce integration.
*   `snowflake-connector-python`: For Snowflake integration.

## 6. Native Integration Plan

This section details how the features will be natively integrated into the Django app.

### 6.1. Auditors and Checks

The existing auditor scripts will be refactored into Python classes that are managed by the Django application. Each auditor class will correspond to a `Service` and will contain methods for each `Check`.

*   **Auditor Runner:** A Celery task will be responsible for running the auditors. It will take the platform, services, and checks to run as arguments.
*   **Check Execution:** The Celery task will instantiate the appropriate auditor class and call the check methods. The check methods will contain the logic for interacting with the cloud/SaaS APIs and evaluating the configuration.
*   **Findings:** The check methods will create `Finding` objects in the database for each finding.

### 6.2. Configuration

The configuration will be managed using Django's settings framework and database models.

*   **Credentials:** Cloud and SaaS credentials will be stored securely, for example, using Django's encrypted fields or a third-party service like HashiCorp Vault.
*   **Targets:** The target accounts, projects, and regions will be configured in the database.

### 6.3. Output and Reporting

The output and reporting will be handled by Django's native features.

*   **API:** The REST API will be the primary way to access the findings.
*   **UI:** A user interface can be built using Django's templating engine or a separate frontend framework that consumes the API.
*   **Reports:** Reports in various formats (HTML, CSV, PDF) can be generated using Django's views and libraries like `WeasyPrint` or `ReportLab`.

### 6.4. Attack Surface Monitoring

The integrations with external tools like Shodan, VirusTotal, and Nmap will be implemented as Celery tasks.

*   **Shodan/VirusTotal Integration:** A Celery task will periodically query the Shodan and VirusTotal APIs for information about the discovered assets.
*   **Nmap Integration:** A Celery task will run Nmap scans against the discovered assets.
*   **Findings:** The results of these scans will be stored as `Finding` objects in the database.

By following this plan, we will create a modern, scalable, and maintainable Django application that natively integrates the core features of ElectricEye. This will provide a solid foundation for future development and new features.
